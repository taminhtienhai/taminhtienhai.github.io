var rn=Object.defineProperty;var an=(n,t,e)=>t in n?rn(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var k=(n,t,e)=>(an(n,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const r of o.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=e(i);fetch(i.href,o)}})();function cn(){if(typeof globalThis<"u")return globalThis;if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;console.warn("XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues")}function dn(){const n=cn();if(n.__xstate__)return n.__xstate__}const ln=n=>{if(typeof window>"u")return;const t=dn();t&&t.register(n)};class Yt{constructor(t){this._process=t,this._active=!1,this._current=null,this._last=null}start(){this._active=!0,this.flush()}clear(){this._current&&(this._current.next=null,this._last=this._current)}enqueue(t){const e={value:t,next:null};if(this._current){this._last.next=e,this._last=e;return}this._current=e,this._last=e,this._active&&this.flush()}flush(){for(;this._current;){const t=this._current;this._process(t.value),this._current=t.next}this._last=null}}const Se=".",hn="",be="",un="#",Et="*",Te="xstate.init",fn="xstate.error",ct="xstate.stop";function pn(n,t){return{type:`xstate.after.${n}.${t}`}}function At(n,t){return{type:`xstate.done.state.${n}`,output:t}}function mn(n,t){return{type:`xstate.done.actor.${n}`,output:t}}function xe(n,t){return{type:`xstate.error.actor.${n}`,error:t}}function Ee(n){return{type:Te,input:n}}function x(n){setTimeout(()=>{throw n})}const yn=typeof Symbol=="function"&&Symbol.observable||"@@observable";function Ft(n,t){return`${n.sessionId}.${t}`}let _n=0;function gn(n,t){const e=new Map,s=new Map,i=new WeakMap,o=new Set,r={},{clock:a,logger:d}=t,c={schedule:(l,u,p,m,_=Math.random().toString(36).slice(2))=>{const S={source:l,target:u,event:p,delay:m,id:_,startedAt:Date.now()},w=Ft(l,_);h._snapshot._scheduledEvents[w]=S;const on=a.setTimeout(()=>{delete r[w],delete h._snapshot._scheduledEvents[w],h._relay(l,u,p)},m);r[w]=on},cancel:(l,u)=>{const p=Ft(l,u),m=r[p];delete r[p],delete h._snapshot._scheduledEvents[p],a.clearTimeout(m)},cancelAll:l=>{for(const u in h._snapshot._scheduledEvents){const p=h._snapshot._scheduledEvents[u];p.source===l&&c.cancel(l,p.id)}}},f=l=>{if(!o.size)return;const u={...l,rootId:n.sessionId};o.forEach(p=>{var m;return(m=p.next)==null?void 0:m.call(p,u)})},h={_snapshot:{_scheduledEvents:((t==null?void 0:t.snapshot)&&t.snapshot.scheduler)??{}},_bookId:()=>`x:${_n++}`,_register:(l,u)=>(e.set(l,u),l),_unregister:l=>{e.delete(l.sessionId);const u=i.get(l);u!==void 0&&(s.delete(u),i.delete(l))},get:l=>s.get(l),_set:(l,u)=>{const p=s.get(l);if(p&&p!==u)throw new Error(`Actor with system ID '${l}' already exists.`);s.set(l,u),i.set(u,l)},inspect:l=>{o.add(l)},_sendInspectionEvent:f,_relay:(l,u,p)=>{h._sendInspectionEvent({type:"@xstate.event",sourceRef:l,actorRef:u,event:p}),u._send(p)},scheduler:c,getSnapshot:()=>({_scheduledEvents:{...h._snapshot._scheduledEvents}}),start:()=>{const l=h._snapshot._scheduledEvents;h._snapshot._scheduledEvents={};for(const u in l){const{source:p,target:m,event:_,delay:S,id:w}=l[u];c.schedule(p,m,_,S,w)}},_clock:a,_logger:d};return h}function Ae(n,t){const e=Xt(n),s=Xt(t);return typeof s=="string"?typeof e=="string"?s===e:!1:typeof e=="string"?e in s:Object.keys(e).every(i=>i in s?Ae(e[i],s[i]):!1)}function Nt(n){if(ke(n))return n;let t=[],e="";for(let s=0;s<n.length;s++){switch(n.charCodeAt(s)){case 92:e+=n[s+1],s++;continue;case 46:t.push(e),e="";continue}e+=n[s]}return t.push(e),t}function Xt(n){if(Yn(n))return n.value;if(typeof n!="string")return n;const t=Nt(n);return $n(t)}function $n(n){if(n.length===1)return n[0];const t={};let e=t;for(let s=0;s<n.length-1;s++)if(s===n.length-2)e[n[s]]=n[s+1];else{const i=e;e={},i[n[s]]=e}return t}function Zt(n,t){const e={},s=Object.keys(n);for(let i=0;i<s.length;i++){const o=s[i];e[o]=t(n[o],o,n,i)}return e}function Ie(n){return ke(n)?n:[n]}function A(n){return n===void 0?[]:Ie(n)}function It(n,t,e,s){return typeof n=="function"?n({context:t,event:e,self:s}):(n&&typeof n=="object"&&Object.values(n).some(i=>typeof i=="function")&&console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.
Found object containing properties whose values are possibly mapping functions: ${Object.entries(n).filter(([i,o])=>typeof o=="function").map(([i,o])=>`
 - ${i}: ${o.toString().replace(/\n\s*/g,"")}`).join("")}`),n)}function ke(n){return Array.isArray(n)}function vn(n){return n.type.startsWith("xstate.error.actor")}function U(n){return Ie(n).map(t=>typeof t>"u"||typeof t=="string"?{target:t}:t)}function Ce(n){if(!(n===void 0||n===hn))return A(n)}function Qt(n,t,e){var o,r,a;const s=typeof n=="object",i=s?n:void 0;return{next:(o=s?n.next:n)==null?void 0:o.bind(i),error:(r=s?n.error:t)==null?void 0:r.bind(i),complete:(a=s?n.complete:e)==null?void 0:a.bind(i)}}function te(n,t){return`${t}.${n}`}function Ot(n,t){const e=t.match(/^xstate\.invoke\.(\d+)\.(.*)/);if(!e)return n.implementations.actors[t];const[,s,i]=e,r=n.getStateNodeById(i).config.invoke;return(Array.isArray(r)?r[s]:r).src}const Pt=1;let v=function(n){return n[n.NotStarted=0]="NotStarted",n[n.Running=1]="Running",n[n.Stopped=2]="Stopped",n}({});const wn={clock:{setTimeout:(n,t)=>setTimeout(n,t),clearTimeout:n=>clearTimeout(n)},logger:console.log.bind(console),devTools:!1};class Sn{constructor(t,e){this.logic=t,this._snapshot=void 0,this.clock=void 0,this.options=void 0,this.id=void 0,this.mailbox=new Yt(this._process.bind(this)),this.observers=new Set,this.eventListeners=new Map,this.logger=void 0,this._processingStatus=v.NotStarted,this._parent=void 0,this._syncSnapshot=void 0,this.ref=void 0,this._actorScope=void 0,this._systemId=void 0,this.sessionId=void 0,this.system=void 0,this._doneEvent=void 0,this.src=void 0,this._deferred=[];const s={...wn,...e},{clock:i,logger:o,parent:r,syncSnapshot:a,id:d,systemId:c,inspect:f}=s;this.system=r?r.system:gn(this,{clock:i,logger:o}),f&&!r&&this.system.inspect(Qt(f)),this.sessionId=this.system._bookId(),this.id=d??this.sessionId,this.logger=(e==null?void 0:e.logger)??this.system._logger,this.clock=(e==null?void 0:e.clock)??this.system._clock,this._parent=r,this._syncSnapshot=a,this.options=s,this.src=s.src??t,this.ref=this,this._actorScope={self:this,id:this.id,sessionId:this.sessionId,logger:this.logger,defer:h=>{this._deferred.push(h)},system:this.system,stopChild:h=>{if(h._parent!==this)throw new Error(`Cannot stop child actor ${h.id} of ${this.id} because it is not a child`);h._stop()},emit:h=>{const l=this.eventListeners.get(h.type);if(l)for(const u of Array.from(l))u(h)}},this.send=this.send.bind(this),this.system._sendInspectionEvent({type:"@xstate.actor",actorRef:this}),c&&(this._systemId=c,this.system._set(c,this)),this._initState((e==null?void 0:e.snapshot)??(e==null?void 0:e.state)),c&&this._snapshot.status!=="active"&&this.system._unregister(this)}_initState(t){var e;try{this._snapshot=t?this.logic.restoreSnapshot?this.logic.restoreSnapshot(t,this._actorScope):t:this.logic.getInitialSnapshot(this._actorScope,(e=this.options)==null?void 0:e.input)}catch(s){this._snapshot={status:"error",output:void 0,error:s}}}update(t,e){var i,o;this._snapshot=t;let s;for(;s=this._deferred.shift();)try{s()}catch(r){this._deferred.length=0,this._snapshot={...t,status:"error",error:r}}switch(this._snapshot.status){case"active":for(const r of this.observers)try{(i=r.next)==null||i.call(r,t)}catch(a){x(a)}break;case"done":for(const r of this.observers)try{(o=r.next)==null||o.call(r,t)}catch(a){x(a)}this._stopProcedure(),this._complete(),this._doneEvent=mn(this.id,this._snapshot.output),this._parent&&this.system._relay(this,this._parent,this._doneEvent);break;case"error":this._error(this._snapshot.error);break}this.system._sendInspectionEvent({type:"@xstate.snapshot",actorRef:this,event:e,snapshot:t})}subscribe(t,e,s){var o;const i=Qt(t,e,s);if(this._processingStatus!==v.Stopped)this.observers.add(i);else switch(this._snapshot.status){case"done":try{(o=i.complete)==null||o.call(i)}catch(r){x(r)}break;case"error":{const r=this._snapshot.error;if(!i.error)x(r);else try{i.error(r)}catch(a){x(a)}break}}return{unsubscribe:()=>{this.observers.delete(i)}}}on(t,e){let s=this.eventListeners.get(t);s||(s=new Set,this.eventListeners.set(t,s));const i=e.bind(void 0);return s.add(i),{unsubscribe:()=>{s.delete(i)}}}start(){if(this._processingStatus===v.Running)return this;this._syncSnapshot&&this.subscribe({next:s=>{s.status==="active"&&this.system._relay(this,this._parent,{type:`xstate.snapshot.${this.id}`,snapshot:s})},error:()=>{}}),this.system._register(this.sessionId,this),this._systemId&&this.system._set(this._systemId,this),this._processingStatus=v.Running;const t=Ee(this.options.input);switch(this.system._sendInspectionEvent({type:"@xstate.event",sourceRef:this._parent,actorRef:this,event:t}),this._snapshot.status){case"done":return this.update(this._snapshot,t),this;case"error":return this._error(this._snapshot.error),this}if(this._parent||this.system.start(),this.logic.start)try{this.logic.start(this._snapshot,this._actorScope)}catch(s){return this._snapshot={...this._snapshot,status:"error",error:s},this._error(s),this}return this.update(this._snapshot,t),this.options.devTools&&this.attachDevTools(),this.mailbox.start(),this}_process(t){let e,s;try{e=this.logic.transition(this._snapshot,t,this._actorScope)}catch(i){s={err:i}}if(s){const{err:i}=s;this._snapshot={...this._snapshot,status:"error",error:i},this._error(i);return}this.update(e,t),t.type===ct&&(this._stopProcedure(),this._complete())}_stop(){return this._processingStatus===v.Stopped?this:(this.mailbox.clear(),this._processingStatus===v.NotStarted?(this._processingStatus=v.Stopped,this):(this.mailbox.enqueue({type:ct}),this))}stop(){if(this._parent)throw new Error("A non-root actor cannot be stopped directly.");return this._stop()}_complete(){var t;for(const e of this.observers)try{(t=e.complete)==null||t.call(e)}catch(s){x(s)}this.observers.clear()}_reportError(t){if(!this.observers.size){this._parent||x(t);return}let e=!1;for(const s of this.observers){const i=s.error;e||(e=!i);try{i==null||i(t)}catch(o){x(o)}}this.observers.clear(),e&&x(t)}_error(t){this._stopProcedure(),this._reportError(t),this._parent&&this.system._relay(this,this._parent,xe(this.id,t))}_stopProcedure(){return this._processingStatus!==v.Running?this:(this.system.scheduler.cancelAll(this),this.mailbox.clear(),this.mailbox=new Yt(this._process.bind(this)),this._processingStatus=v.Stopped,this.system._unregister(this),this)}_send(t){if(this._processingStatus===v.Stopped){{const e=JSON.stringify(t);console.warn(`Event "${t.type}" was sent to stopped actor "${this.id} (${this.sessionId})". This actor has already reached its final state, and will not transition.
Event: ${e}`)}return}this.mailbox.enqueue(t)}send(t){if(typeof t=="string")throw new Error(`Only event objects may be sent to actors; use .send({ type: "${t}" }) instead`);this.system._relay(void 0,this,t)}attachDevTools(){const{devTools:t}=this.options;t&&(typeof t=="function"?t:ln)(this)}toJSON(){return{xstate$$type:Pt,id:this.id}}getPersistedSnapshot(t){return this.logic.getPersistedSnapshot(this._snapshot,t)}[yn](){return this}getSnapshot(){if(!this._snapshot)throw new Error("Snapshot can't be read while the actor initializes itself");return this._snapshot}}function X(n,...[t]){return new Sn(n,t)}function bn(n,t,e,s,{sendId:i}){const o=typeof i=="function"?i(e,s):i;return[t,o]}function Tn(n,t){n.defer(()=>{n.system.scheduler.cancel(n.self,t)})}function xn(n){function t(e,s){throw new Error("This isn't supposed to be called")}return t.type="xstate.cancel",t.sendId=n,t.resolve=bn,t.execute=Tn,t}function En(n,t,e,s,{id:i,systemId:o,src:r,input:a,syncSnapshot:d}){const c=typeof r=="string"?Ot(t.machine,r):r,f=typeof i=="function"?i(e):i;let h;return c&&(h=X(c,{id:f,src:r,parent:n.self,syncSnapshot:d,systemId:o,input:typeof a=="function"?a({context:t.context,event:e.event,self:n.self}):a})),h||console.warn(`Actor type '${r}' not found in machine '${n.id}'.`),[V(t,{children:{...t.children,[f]:h}}),{id:i,actorRef:h}]}function An(n,{id:t,actorRef:e}){e&&n.defer(()=>{e._processingStatus!==v.Stopped&&e.start()})}function In(...[n,{id:t,systemId:e,input:s,syncSnapshot:i=!1}={}]){function o(r,a){throw new Error("This isn't supposed to be called")}return o.type="snapshot.spawnChild",o.id=t,o.systemId=e,o.src=n,o.input=s,o.syncSnapshot=i,o.resolve=En,o.execute=An,o}function kn(n,t,e,s,{actorRef:i}){const o=typeof i=="function"?i(e,s):i,r=typeof o=="string"?t.children[o]:o;let a=t.children;return r&&(a={...a},delete a[r.id]),[V(t,{children:a}),r]}function Cn(n,t){if(t){if(n.system._unregister(t),t._processingStatus!==v.Running){n.stopChild(t);return}n.defer(()=>{n.stopChild(t)})}}function Me(n){function t(e,s){throw new Error("This isn't supposed to be called")}return t.type="xstate.stopChild",t.actorRef=n,t.resolve=kn,t.execute=Cn,t}function Lt(n,t,e,s){const{machine:i}=s,o=typeof n=="function",r=o?n:i.implementations.guards[typeof n=="string"?n:n.type];if(!o&&!r)throw new Error(`Guard '${typeof n=="string"?n:n.type}' is not implemented.'.`);if(typeof r!="function")return Lt(r,t,e,s);const a={context:t,event:e},d=o||typeof n=="string"?void 0:"params"in n?typeof n.params=="function"?n.params({context:t,event:e}):n.params:void 0;return"check"in r?r.check(s,a,r):r(a,d)}const Vt=n=>n.type==="atomic"||n.type==="final";function J(n){return Object.values(n.states).filter(t=>t.type!=="history")}function st(n,t){const e=[];if(t===n)return e;let s=n.parent;for(;s&&s!==t;)e.push(s),s=s.parent;return e}function dt(n){const t=new Set(n),e=Ne(t);for(const s of t)if(s.type==="compound"&&(!e.get(s)||!e.get(s).length))ee(s).forEach(i=>t.add(i));else if(s.type==="parallel"){for(const i of J(s))if(i.type!=="history"&&!t.has(i)){const o=ee(i);for(const r of o)t.add(r)}}for(const s of t){let i=s.parent;for(;i;)t.add(i),i=i.parent}return t}function Re(n,t){const e=t.get(n);if(!e)return{};if(n.type==="compound"){const i=e[0];if(i){if(Vt(i))return i.key}else return{}}const s={};for(const i of e)s[i.key]=Re(i,t);return s}function Ne(n){const t=new Map;for(const e of n)t.has(e)||t.set(e,[]),e.parent&&(t.has(e.parent)||t.set(e.parent,[]),t.get(e.parent).push(e));return t}function Oe(n,t){const e=dt(t);return Re(n,Ne(e))}function jt(n,t){return t.type==="compound"?J(t).some(e=>e.type==="final"&&n.has(e)):t.type==="parallel"?J(t).every(e=>jt(n,e)):t.type==="final"}const pt=n=>n[0]===un;function Mn(n,t){return n.transitions.get(t)||[...n.transitions.keys()].filter(s=>{if(s===Et)return!0;if(!s.endsWith(".*"))return!1;/.*\*.+/.test(s)&&console.warn(`Wildcards can only be the last token of an event descriptor (e.g., "event.*") or the entire event descriptor ("*"). Check the "${s}" event.`);const i=s.split("."),o=t.split(".");for(let r=0;r<i.length;r++){const a=i[r],d=o[r];if(a==="*"){const c=r===i.length-1;return c||console.warn(`Infix wildcards in transition events are not allowed. Check the "${s}" transition.`),c}if(a!==d)return!1}return!0}).sort((s,i)=>i.length-s.length).flatMap(s=>n.transitions.get(s))}function Rn(n){const t=n.config.after;if(!t)return[];const e=(i,o)=>{const r=pn(i,n.id),a=r.type;return n.entry.push(is(r,{id:a,delay:i})),n.exit.push(xn(a)),a};return Object.keys(t).flatMap((i,o)=>{const r=t[i],a=typeof r=="string"?{target:r}:r,d=Number.isNaN(+i)?i:+i,c=e(d);return A(a).map(f=>({...f,event:c,delay:d}))}).map(i=>{const{delay:o}=i;return{...R(n,i.event,i),delay:o}})}function R(n,t,e){const s=Ce(e.target),i=e.reenter??!1,o=Pn(n,s);if(e.cond)throw new Error(`State "${n.id}" has declared \`cond\` for one of its transitions. This property has been renamed to \`guard\`. Please update your code.`);const r={...e,actions:A(e.actions),guard:e.guard,target:o,source:n,reenter:i,eventType:t,toJSON:()=>({...r,source:`#${n.id}`,target:o?o.map(a=>`#${a.id}`):void 0})};return r}function Nn(n){const t=new Map;if(n.config.on)for(const e of Object.keys(n.config.on)){if(e===be)throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');const s=n.config.on[e];t.set(e,U(s).map(i=>R(n,e,i)))}if(n.config.onDone){const e=`xstate.done.state.${n.id}`;t.set(e,U(n.config.onDone).map(s=>R(n,e,s)))}for(const e of n.invoke){if(e.onDone){const s=`xstate.done.actor.${e.id}`;t.set(s,U(e.onDone).map(i=>R(n,s,i)))}if(e.onError){const s=`xstate.error.actor.${e.id}`;t.set(s,U(e.onError).map(i=>R(n,s,i)))}if(e.onSnapshot){const s=`xstate.snapshot.${e.id}`;t.set(s,U(e.onSnapshot).map(i=>R(n,s,i)))}}for(const e of n.after){let s=t.get(e.eventType);s||(s=[],t.set(e.eventType,s)),s.push(e)}return t}function On(n,t){const e=typeof t=="string"?n.states[t]:t?n.states[t.target]:void 0;if(!e&&t)throw new Error(`Initial state node "${t}" not found on parent state node #${n.id}`);const s={source:n,actions:!t||typeof t=="string"?[]:A(t.actions),eventType:null,reenter:!1,target:e?[e]:[],toJSON:()=>({...s,source:`#${n.id}`,target:e?[`#${e.id}`]:[]})};return s}function Pn(n,t){if(t!==void 0)return t.map(e=>{if(typeof e!="string")return e;if(pt(e))return n.machine.getStateNodeById(e);const s=e[0]===Se;if(s&&!n.parent)return lt(n,e.slice(1));const i=s?n.key+e:e;if(n.parent)try{return lt(n.parent,i)}catch(o){throw new Error(`Invalid transition definition for state node '${n.id}':
${o.message}`)}else throw new Error(`Invalid target: "${e}" is not a valid target from the root node. Did you mean ".${e}"?`)})}function Pe(n){const t=Ce(n.config.target);return t?{target:t.map(e=>typeof e=="string"?lt(n.parent,e):e)}:n.parent.initial}function N(n){return n.type==="history"}function ee(n){const t=Le(n);for(const e of t)for(const s of st(e,n))t.add(s);return t}function Le(n){const t=new Set;function e(s){if(!t.has(s)){if(t.add(s),s.type==="compound")e(s.initial.target[0]);else if(s.type==="parallel")for(const i of J(s))e(i)}}return e(n),t}function K(n,t){if(pt(t))return n.machine.getStateNodeById(t);if(!n.states)throw new Error(`Unable to retrieve child state '${t}' from '${n.id}'; no child states exist.`);const e=n.states[t];if(!e)throw new Error(`Child state '${t}' does not exist on '${n.id}'`);return e}function lt(n,t){if(typeof t=="string"&&pt(t))try{return n.machine.getStateNodeById(t)}catch{}const e=Nt(t).slice();let s=n;for(;e.length;){const i=e.shift();if(!i.length)break;s=K(s,i)}return s}function ht(n,t){if(typeof t=="string"){const i=n.states[t];if(!i)throw new Error(`State '${t}' does not exist on '${n.id}'`);return[n,i]}const e=Object.keys(t),s=e.map(i=>K(n,i)).filter(Boolean);return[n.machine.root,n].concat(s,e.reduce((i,o)=>{const r=K(n,o);if(!r)return i;const a=ht(r,t[o]);return i.concat(a)},[]))}function Ln(n,t,e,s){const o=K(n,t).next(e,s);return!o||!o.length?n.next(e,s):o}function Vn(n,t,e,s){const i=Object.keys(t),o=K(n,i[0]),r=Dt(o,t[i[0]],e,s);return!r||!r.length?n.next(e,s):r}function jn(n,t,e,s){const i=[];for(const o of Object.keys(t)){const r=t[o];if(!r)continue;const a=K(n,o),d=Dt(a,r,e,s);d&&i.push(...d)}return i.length?i:n.next(e,s)}function Dt(n,t,e,s){return typeof t=="string"?Ln(n,t,e,s):Object.keys(t).length===1?Vn(n,t,e,s):jn(n,t,e,s)}function Dn(n){return Object.keys(n.states).map(t=>n.states[t]).filter(t=>t.type==="history")}function I(n,t){let e=n;for(;e.parent&&e.parent!==t;)e=e.parent;return e.parent===t}function zn(n,t){const e=new Set(n),s=new Set(t);for(const i of e)if(s.has(i))return!0;for(const i of s)if(e.has(i))return!0;return!1}function Ve(n,t,e){const s=new Set;for(const i of n){let o=!1;const r=new Set;for(const a of s)if(zn(kt([i],t,e),kt([a],t,e)))if(I(i.source,a.source))r.add(a);else{o=!0;break}if(!o){for(const a of r)s.delete(a);s.add(i)}}return Array.from(s)}function Hn(n){const[t,...e]=n;for(const s of st(t,void 0))if(e.every(i=>I(i,s)))return s}function zt(n,t){if(!n.target)return[];const e=new Set;for(const s of n.target)if(N(s))if(t[s.id])for(const i of t[s.id])e.add(i);else for(const i of zt(Pe(s),t))e.add(i);else e.add(s);return[...e]}function je(n,t){const e=zt(n,t);if(!e)return;if(!n.reenter&&e.every(i=>i===n.source||I(i,n.source)))return n.source;const s=Hn(e.concat(n.source));if(s)return s;if(!n.reenter)return n.source.machine.root}function kt(n,t,e){var i;const s=new Set;for(const o of n)if((i=o.target)!=null&&i.length){const r=je(o,e);o.reenter&&o.source===r&&s.add(r);for(const a of t)I(a,r)&&s.add(a)}return[...s]}function Bn(n,t){if(n.length!==t.size)return!1;for(const e of n)if(!t.has(e))return!1;return!0}function Ct(n,t,e,s,i,o){if(!n.length)return t;const r=new Set(t._nodes);let a=t.historyValue;const d=Ve(n,r,a);let c=t;i||([c,a]=Kn(c,s,e,d,r,a,o)),c=q(c,s,e,d.flatMap(h=>h.actions),o),c=Wn(c,s,e,d,r,o,a,i);const f=[...r];c.status==="done"&&(c=q(c,s,e,f.sort((h,l)=>l.order-h.order).flatMap(h=>h.exit),o));try{return a===t.historyValue&&Bn(t._nodes,r)?c:V(c,{_nodes:f,historyValue:a})}catch(h){throw h}}function Un(n,t,e,s,i){if(s.output===void 0)return;const o=At(i.id,i.output!==void 0&&i.parent?It(i.output,n.context,t,e.self):void 0);return It(s.output,n.context,o,e.self)}function Wn(n,t,e,s,i,o,r,a){let d=n;const c=new Set,f=new Set;Jn(s,r,f,c),a&&f.add(n.machine.root);const h=new Set;for(const l of[...c].sort((u,p)=>u.order-p.order)){i.add(l);const u=[];u.push(...l.entry);for(const p of l.invoke)u.push(In(p.src,{...p,syncSnapshot:!!p.onSnapshot}));if(f.has(l)){const p=l.initial.actions;u.push(...p)}if(d=q(d,t,e,u,o,l.invoke.map(p=>p.id)),l.type==="final"){const p=l.parent;let m=(p==null?void 0:p.type)==="parallel"?p:p==null?void 0:p.parent,_=m||l;for((p==null?void 0:p.type)==="compound"&&o.push(At(p.id,l.output!==void 0?It(l.output,d.context,t,e.self):void 0));(m==null?void 0:m.type)==="parallel"&&!h.has(m)&&jt(i,m);)h.add(m),o.push(At(m.id)),_=m,m=m.parent;if(m)continue;d=V(d,{status:"done",output:Un(d,t,e,d.machine.root,_)})}}return d}function Jn(n,t,e,s){for(const i of n){const o=je(i,t);for(const a of i.target||[])!N(a)&&(i.source!==a||i.source!==o||i.reenter)&&(s.add(a),e.add(a)),W(a,t,e,s);const r=zt(i,t);for(const a of r){const d=st(a,o);(o==null?void 0:o.type)==="parallel"&&d.push(o),De(s,t,e,d,!i.source.parent&&i.reenter?void 0:o)}}}function W(n,t,e,s){var i;if(N(n))if(t[n.id]){const o=t[n.id];for(const r of o)s.add(r),W(r,t,e,s);for(const r of o)_t(r,n.parent,s,t,e)}else{const o=Pe(n);for(const r of o.target)s.add(r),o===((i=n.parent)==null?void 0:i.initial)&&e.add(n.parent),W(r,t,e,s);for(const r of o.target)_t(r,n.parent,s,t,e)}else if(n.type==="compound"){const[o]=n.initial.target;N(o)||(s.add(o),e.add(o)),W(o,t,e,s),_t(o,n,s,t,e)}else if(n.type==="parallel")for(const o of J(n).filter(r=>!N(r)))[...s].some(r=>I(r,o))||(N(o)||(s.add(o),e.add(o)),W(o,t,e,s))}function De(n,t,e,s,i){for(const o of s)if((!i||I(o,i))&&n.add(o),o.type==="parallel")for(const r of J(o).filter(a=>!N(a)))[...n].some(a=>I(a,r))||(n.add(r),W(r,t,e,n))}function _t(n,t,e,s,i){De(e,s,i,st(n,t))}function Kn(n,t,e,s,i,o,r){let a=n;const d=kt(s,i,o);d.sort((f,h)=>h.order-f.order);let c;for(const f of d)for(const h of Dn(f)){let l;h.history==="deep"?l=u=>Vt(u)&&I(u,f):l=u=>u.parent===f,c??(c={...o}),c[h.id]=Array.from(i).filter(l)}for(const f of d)a=q(a,t,e,[...f.exit,...f.invoke.map(h=>Me(h.id))],r),i.delete(f);return[a,c||o]}let Z=!1;function ze(n,t,e,s,i,o){const{machine:r}=n;let a=n;for(const c of s){let p=function(){e.system._sendInspectionEvent({type:"@xstate.action",actorRef:e.self,action:{type:typeof c=="string"?c:typeof c=="object"?c.type:c.name||"(anonymous)",params:u}});try{Z=h,h(l,u)}finally{Z=!1}};var d=p;const f=typeof c=="function",h=f?c:r.implementations.actions[typeof c=="string"?c:c.type];if(!h)continue;const l={context:a.context,event:t,self:e.self,system:e.system},u=f||typeof c=="string"?void 0:"params"in c?typeof c.params=="function"?c.params({context:a.context,event:t}):c.params:void 0;if(!("resolve"in h)){e.self._processingStatus===v.Running?p():e.defer(()=>{p()});continue}const m=h,[_,S,w]=m.resolve(e,a,l,u,h,i);a=_,"retryResolve"in m&&(o==null||o.push([m,S])),"execute"in m&&(e.self._processingStatus===v.Running?m.execute(e,S):e.defer(m.execute.bind(null,e,S))),w&&(a=ze(a,t,e,w,i,o))}return a}function q(n,t,e,s,i,o){const r=o?[]:void 0,a=ze(n,t,e,s,{internalQueue:i,deferredActorIds:o},r);return r==null||r.forEach(([d,c])=>{d.retryResolve(e,a,c)}),a}function gt(n,t,e,s=[]){if(t.type===Et)throw new Error(`An event cannot have the wildcard type ('${Et}')`);let i=n;const o=[];function r(c,f,h){e.system._sendInspectionEvent({type:"@xstate.microstep",actorRef:e.self,event:f,snapshot:c,_transitions:h}),o.push(c)}if(t.type===ct)return i=V(ne(i,t,e),{status:"stopped"}),r(i,t,[]),{snapshot:i,microstates:o};let a=t;if(a.type!==Te){const c=a,f=vn(c),h=se(c,i);if(f&&!h.length)return i=V(n,{status:"error",error:c.error}),r(i,c,[]),{snapshot:i,microstates:o};i=Ct(h,n,e,a,!1,s),r(i,c,h)}let d=!0;for(;i.status==="active";){let c=d?qn(i,a):[];const f=c.length?i:void 0;if(!c.length){if(!s.length)break;a=s.shift(),c=se(a,i)}i=Ct(c,i,e,a,!1,s),d=i!==f,r(i,a,c)}return i.status!=="active"&&ne(i,a,e),{snapshot:i,microstates:o}}function ne(n,t,e){return q(n,t,e,Object.values(n.children).map(s=>Me(s)),[])}function se(n,t){return t.machine.getTransitionData(t,n)}function qn(n,t){const e=new Set,s=n._nodes.filter(Vt);for(const i of s)t:for(const o of[i].concat(st(i,void 0)))if(o.always){for(const r of o.always)if(r.guard===void 0||Lt(r.guard,n.context,t,n)){e.add(r);break t}}return Ve(Array.from(e),new Set(n._nodes),n.historyValue)}function Gn(n,t){const e=dt(ht(n,t));return Oe(n,[...e])}function Yn(n){return!!n&&typeof n=="object"&&"machine"in n&&"value"in n}const Fn=function(t){return Ae(t,this.value)},Xn=function(t){return this.tags.has(t)},Zn=function(t){this.machine||console.warn("state.can(...) used outside of a machine-created State object; this will always return false.");const e=this.machine.getTransitionData(this,t);return!!(e!=null&&e.length)&&e.some(s=>s.target!==void 0||s.actions.length)},Qn=function(){const{_nodes:t,tags:e,machine:s,getMeta:i,toJSON:o,can:r,hasTag:a,matches:d,...c}=this;return{...c,tags:Array.from(e)}},ts=function(){return this._nodes.reduce((t,e)=>(e.meta!==void 0&&(t[e.id]=e.meta),t),{})};function at(n,t){return{status:n.status,output:n.output,error:n.error,machine:t,context:n.context,_nodes:n._nodes,value:Oe(t.root,n._nodes),tags:new Set(n._nodes.flatMap(e=>e.tags)),children:n.children,historyValue:n.historyValue||{},matches:Fn,hasTag:Xn,can:Zn,getMeta:ts,toJSON:Qn}}function V(n,t={}){return at({...n,...t},n.machine)}function es(n,t){const{_nodes:e,tags:s,machine:i,children:o,context:r,can:a,hasTag:d,matches:c,getMeta:f,toJSON:h,...l}=n,u={};for(const m in o){const _=o[m];if(typeof _.src!="string"&&(!t||!("__unsafeAllowInlineActors"in t)))throw new Error("An inline child actor cannot be persisted.");u[m]={snapshot:_.getPersistedSnapshot(t),src:_.src,systemId:_._systemId,syncSnapshot:_._syncSnapshot}}return{...l,context:He(r),children:u}}function He(n){let t;for(const e in n){const s=n[e];if(s&&typeof s=="object")if("sessionId"in s&&"send"in s&&"ref"in s)t??(t=Array.isArray(n)?n.slice():{...n}),t[e]={xstate$$type:Pt,id:s.id};else{const i=He(s);i!==s&&(t??(t=Array.isArray(n)?n.slice():{...n}),t[e]=i)}}return t??n}function ns(n,t,e,s,{event:i,id:o,delay:r},{internalQueue:a}){const d=t.machine.implementations.delays;if(typeof i=="string")throw new Error(`Only event objects may be used with raise; use raise({ type: "${i}" }) instead`);const c=typeof i=="function"?i(e,s):i;let f;if(typeof r=="string"){const h=d&&d[r];f=typeof h=="function"?h(e,s):h}else f=typeof r=="function"?r(e,s):r;return typeof f!="number"&&a.push(c),[t,{event:c,id:o,delay:f}]}function ss(n,t){const{event:e,delay:s,id:i}=t;if(typeof s=="number"){n.defer(()=>{const o=n.self;n.system.scheduler.schedule(o,o,e,s,i)});return}}function is(n,t){Z&&console.warn("Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");function e(s,i){throw new Error("This isn't supposed to be called")}return e.type="xstate.raise",e.event=n,e.id=t==null?void 0:t.id,e.delay=t==null?void 0:t.delay,e.resolve=ns,e.execute=ss,e}const ie="xstate.promise.resolve",oe="xstate.promise.reject",ot=new WeakMap;function os(n){return{config:n,transition:(e,s,i)=>{var o;if(e.status!=="active")return e;switch(s.type){case ie:{const r=s.data;return{...e,status:"done",output:r,input:void 0}}case oe:return{...e,status:"error",error:s.data,input:void 0};case ct:return(o=ot.get(i.self))==null||o.abort(),{...e,status:"stopped",input:void 0};default:return e}},start:(e,{self:s,system:i})=>{if(e.status!=="active")return;const o=new AbortController;ot.set(s,o),Promise.resolve(n({input:e.input,system:i,self:s,signal:o.signal})).then(a=>{s.getSnapshot().status==="active"&&(ot.delete(s),i._relay(s,s,{type:ie,data:a}))},a=>{s.getSnapshot().status==="active"&&(ot.delete(s),i._relay(s,s,{type:oe,data:a}))})},getInitialSnapshot:(e,s)=>({status:"active",output:void 0,error:void 0,input:s}),getPersistedSnapshot:e=>e,restoreSnapshot:e=>e}}function rs(n,{machine:t,context:e},s,i){const o=(r,a={})=>{const{systemId:d,input:c}=a;if(typeof r=="string"){const f=Ot(t,r);if(!f)throw new Error(`Actor logic '${r}' not implemented in machine '${t.id}'`);const h=X(f,{id:a.id,parent:n.self,syncSnapshot:a.syncSnapshot,input:typeof c=="function"?c({context:e,event:s,self:n.self}):c,src:r,systemId:d});return i[h.id]=h,h}else return X(r,{id:a.id,parent:n.self,syncSnapshot:a.syncSnapshot,input:a.input,src:r,systemId:d})};return(r,a)=>{const d=o(r,a);return i[d.id]=d,n.defer(()=>{d._processingStatus!==v.Stopped&&d.start()}),d}}function as(n,t,e,s,{assignment:i}){if(!t.context)throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");const o={},r={context:t.context,event:e.event,spawn:rs(n,t,e.event,o),self:n.self,system:n.system};let a={};if(typeof i=="function")a=i(r,s);else for(const c of Object.keys(i)){const f=i[c];a[c]=typeof f=="function"?f(r,s):f}const d=Object.assign({},t.context,a);return[V(t,{context:d,children:Object.keys(o).length?{...t.children,...o}:t.children})]}function cs(n){Z&&console.warn("Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");function t(e,s){throw new Error("This isn't supposed to be called")}return t.type="xstate.assign",t.assignment=n,t.resolve=as,t}let re=function(n){return n.Parent="#_parent",n.Internal="#_internal",n}({});function ds(n,t,e,s,{to:i,event:o,id:r,delay:a},d){var p;const c=t.machine.implementations.delays;if(typeof o=="string")throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${o}" }) instead`);const f=typeof o=="function"?o(e,s):o;let h;if(typeof a=="string"){const m=c&&c[a];h=typeof m=="function"?m(e,s):m}else h=typeof a=="function"?a(e,s):a;const l=typeof i=="function"?i(e,s):i;let u;if(typeof l=="string"){if(l===re.Parent?u=n.self._parent:l===re.Internal?u=n.self:l.startsWith("#_")?u=t.children[l.slice(2)]:u=(p=d.deferredActorIds)!=null&&p.includes(l)?l:t.children[l],!u)throw new Error(`Unable to send event to actor '${l}' from machine '${t.machine.id}'.`)}else u=l||n.self;return[t,{to:u,event:f,id:r,delay:h}]}function ls(n,t,e){typeof e.to=="string"&&(e.to=t.children[e.to])}function hs(n,t){n.defer(()=>{const{to:e,event:s,delay:i,id:o}=t;if(typeof i=="number"){n.system.scheduler.schedule(n.self,e,s,i,o);return}n.system._relay(n.self,e,s.type===fn?xe(n.self.id,s.data):s)})}function ae(n,t,e){Z&&console.warn("Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");function s(i,o){throw new Error("This isn't supposed to be called")}return s.type="xsnapshot.sendTo",s.to=n,s.event=t,s.id=e==null?void 0:e.id,s.delay=e==null?void 0:e.delay,s.resolve=ds,s.retryResolve=ls,s.execute=hs,s}const ce=new WeakMap;function B(n,t,e){let s=ce.get(n);return s?t in s||(s[t]=e()):(s={[t]:e()},ce.set(n,s)),s[t]}const us={},G=n=>typeof n=="string"?{type:n}:typeof n=="function"?"resolve"in n?{type:n.type}:{type:n.name}:n;class Ht{constructor(t,e){if(this.config=t,this.key=void 0,this.id=void 0,this.type=void 0,this.path=void 0,this.states=void 0,this.history=void 0,this.entry=void 0,this.exit=void 0,this.parent=void 0,this.machine=void 0,this.meta=void 0,this.output=void 0,this.order=-1,this.description=void 0,this.tags=[],this.transitions=void 0,this.always=void 0,this.parent=e._parent,this.key=e._key,this.machine=e._machine,this.path=this.parent?this.parent.path.concat(this.key):[],this.id=this.config.id||[this.machine.id,...this.path].join(Se),this.type=this.config.type||(this.config.states&&Object.keys(this.config.states).length?"compound":this.config.history?"history":"atomic"),this.description=this.config.description,this.order=this.machine.idMap.size,this.machine.idMap.set(this.id,this),this.states=this.config.states?Zt(this.config.states,(s,i)=>new Ht(s,{_parent:this,_key:i,_machine:this.machine})):us,this.type==="compound"&&!this.config.initial)throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);this.history=this.config.history===!0?"shallow":this.config.history||!1,this.entry=A(this.config.entry).slice(),this.exit=A(this.config.exit).slice(),this.meta=this.config.meta,this.output=this.type==="final"||!this.parent?this.config.output:void 0,this.tags=A(t.tags).slice()}_initialize(){this.transitions=Nn(this),this.config.always&&(this.always=U(this.config.always).map(t=>R(this,be,t))),Object.keys(this.states).forEach(t=>{this.states[t]._initialize()})}get definition(){return{id:this.id,key:this.key,version:this.machine.version,type:this.type,initial:this.initial?{target:this.initial.target,source:this,actions:this.initial.actions.map(G),eventType:null,reenter:!1,toJSON:()=>({target:this.initial.target.map(t=>`#${t.id}`),source:`#${this.id}`,actions:this.initial.actions.map(G),eventType:null})}:void 0,history:this.history,states:Zt(this.states,t=>t.definition),on:this.on,transitions:[...this.transitions.values()].flat().map(t=>({...t,actions:t.actions.map(G)})),entry:this.entry.map(G),exit:this.exit.map(G),meta:this.meta,order:this.order||-1,output:this.output,invoke:this.invoke,description:this.description,tags:this.tags}}toJSON(){return this.definition}get invoke(){return B(this,"invoke",()=>A(this.config.invoke).map((t,e)=>{const{src:s,systemId:i}=t,o=t.id??te(this.id,e),r=typeof s=="string"?s:`xstate.invoke.${te(this.id,e)}`;return{...t,src:r,id:o,systemId:i,toJSON(){const{onDone:a,onError:d,...c}=t;return{...c,type:"xstate.invoke",src:r,id:o}}}}))}get on(){return B(this,"on",()=>[...this.transitions].flatMap(([e,s])=>s.map(i=>[e,i])).reduce((e,[s,i])=>(e[s]=e[s]||[],e[s].push(i),e),{}))}get after(){return B(this,"delayedTransitions",()=>Rn(this))}get initial(){return B(this,"initial",()=>On(this,this.config.initial))}next(t,e){const s=e.type,i=[];let o;const r=B(this,`candidates-${s}`,()=>Mn(this,s));for(const a of r){const{guard:d}=a,c=t.context;let f=!1;try{f=!d||Lt(d,c,e,t)}catch(h){const l=typeof d=="string"?d:typeof d=="object"?d.type:void 0;throw new Error(`Unable to evaluate guard ${l?`'${l}' `:""}in transition for event '${s}' in state node '${this.id}':
${h.message}`)}if(f){i.push(...a.actions),o=a;break}}return o?[o]:void 0}get events(){return B(this,"events",()=>{const{states:t}=this,e=new Set(this.ownEvents);if(t)for(const s of Object.keys(t)){const i=t[s];if(i.states)for(const o of i.events)e.add(`${o}`)}return Array.from(e)})}get ownEvents(){const t=new Set([...this.transitions.keys()].filter(e=>this.transitions.get(e).some(s=>!(!s.target&&!s.actions.length&&!s.reenter))));return Array.from(t)}}const fs="#";class Bt{constructor(t,e){this.config=t,this.version=void 0,this.schemas=void 0,this.implementations=void 0,this.__xstatenode=!0,this.idMap=new Map,this.root=void 0,this.id=void 0,this.states=void 0,this.events=void 0,this.__TResolvedTypesMeta=void 0,this.id=t.id||"(machine)",this.implementations={actors:(e==null?void 0:e.actors)??{},actions:(e==null?void 0:e.actions)??{},delays:(e==null?void 0:e.delays)??{},guards:(e==null?void 0:e.guards)??{}},this.version=this.config.version,this.schemas=this.config.schemas,this.transition=this.transition.bind(this),this.getInitialSnapshot=this.getInitialSnapshot.bind(this),this.getPersistedSnapshot=this.getPersistedSnapshot.bind(this),this.restoreSnapshot=this.restoreSnapshot.bind(this),this.start=this.start.bind(this),this.root=new Ht(t,{_key:this.id,_machine:this}),this.root._initialize(),this.states=this.root.states,this.events=this.root.events,!("output"in this.root)&&Object.values(this.states).some(s=>s.type==="final"&&"output"in s)&&console.warn("Missing `machine.output` declaration (top-level final state with output detected)")}provide(t){const{actions:e,guards:s,actors:i,delays:o}=this.implementations;return new Bt(this.config,{actions:{...e,...t.actions},guards:{...s,...t.guards},actors:{...i,...t.actors},delays:{...o,...t.delays}})}resolveState(t){const e=Gn(this.root,t.value),s=dt(ht(this.root,e));return at({_nodes:[...s],context:t.context||{},children:{},status:jt(s,this.root)?"done":t.status||"active",output:t.output,error:t.error,historyValue:t.historyValue},this)}transition(t,e,s){return gt(t,e,s).snapshot}microstep(t,e,s){return gt(t,e,s).microstates}getTransitionData(t,e){return Dt(this.root,t.value,t,e)||[]}getPreInitialState(t,e,s){const{context:i}=this.config,o=at({context:typeof i!="function"&&i?i:{},_nodes:[this.root],children:{},status:"active"},this);return typeof i=="function"?q(o,e,t,[cs(({spawn:a,event:d,self:c})=>i({spawn:a,input:d.input,self:c}))],s):o}getInitialSnapshot(t,e){const s=Ee(e),i=[],o=this.getPreInitialState(t,s,i),r=Ct([{target:[...Le(this.root)],source:this.root,reenter:!0,actions:[],eventType:null,toJSON:null}],o,t,s,!0,i),{snapshot:a}=gt(r,s,t,i);return a}start(t){Object.values(t.children).forEach(e=>{e.getSnapshot().status==="active"&&e.start()})}getStateNodeById(t){const e=Nt(t),s=e.slice(1),i=pt(e[0])?e[0].slice(fs.length):e[0],o=this.idMap.get(i);if(!o)throw new Error(`Child state node '#${i}' does not exist on machine '${this.id}'`);return lt(o,s)}get definition(){return this.root.definition}toJSON(){return this.definition}getPersistedSnapshot(t,e){return es(t,e)}restoreSnapshot(t,e){const s={},i=t.children;Object.keys(i).forEach(d=>{const c=i[d],f=c.snapshot,h=c.src,l=typeof h=="string"?Ot(this,h):h;if(!l)return;const u=X(l,{id:d,parent:e.self,syncSnapshot:c.syncSnapshot,snapshot:f,src:h,systemId:c.systemId});s[d]=u});const o=at({...t,children:s,_nodes:Array.from(dt(ht(this.root,t.value)))},this);let r=new Set;function a(d,c){if(!r.has(d)){r.add(d);for(let f in d){const h=d[f];if(h&&typeof h=="object"){if("xstate$$type"in h&&h.xstate$$type===Pt){d[f]=c[h.id];continue}a(h,c)}}}}return a(o.context,s),o}}function ps(n,t){return new Bt(n,t)}function Ut({schemas:n,actors:t,actions:e,guards:s,delays:i}){return{createMachine:o=>ps({...o,schemas:n},{actors:t,actions:e,guards:s,delays:i})}}function ms(n,t){const e=A(t);if(!e.includes(n.type)){const s=e.length===1?`type "${e[0]}"`:`one of types "${e.join('", "')}"`;throw new Error(`Expected event ${JSON.stringify(n)} to have ${s}`)}}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const $=globalThis,y=n=>{$.emitLitDebugLogEvents&&$.dispatchEvent(new CustomEvent("lit-debug",{detail:n}))};let ys=0,Q;$.litIssuedWarnings??($.litIssuedWarnings=new Set),Q=(n,t)=>{t+=n?` See https://lit.dev/msg/${n} for more information.`:"",$.litIssuedWarnings.has(t)||(console.warn(t),$.litIssuedWarnings.add(t))},Q("dev-mode","Lit is in dev mode. Not recommended for production!");var ge,$e;const b=(ge=$.ShadyDOM)!=null&&ge.inUse&&(($e=$.ShadyDOM)==null?void 0:$e.noPatch)===!0?$.ShadyDOM.wrap:n=>n,ut=$.trustedTypes,de=ut?ut.createPolicy("lit-html",{createHTML:n=>n}):void 0,_s=n=>n,mt=(n,t,e)=>_s,gs=n=>{if(z!==mt)throw new Error("Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.");z=n},$s=()=>{z=mt},Mt=(n,t,e)=>z(n,t,e),Wt="$lit$",T=`lit$${Math.random().toFixed(9).slice(2)}$`,Jt="?"+T,vs=`<${Jt}>`,j=document,tt=()=>j.createComment(""),et=n=>n===null||typeof n!="object"&&typeof n!="function",Be=Array.isArray,Ue=n=>Be(n)||typeof(n==null?void 0:n[Symbol.iterator])=="function",$t=`[ 	
\f\r]`,ws=`[^ 	
\f\r"'\`<>=]`,Ss=`[^\\s"'>=/]`,Y=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,le=1,vt=2,bs=3,he=/-->/g,ue=/>/g,C=new RegExp(`>|${$t}(?:(${Ss}+)(${$t}*=${$t}*(?:${ws}|("|')|))|$)`,"g"),Ts=0,fe=1,xs=2,pe=3,wt=/'/g,St=/"/g,We=/^(?:script|style|textarea|title)$/i,Je=1,Rt=2,Kt=1,ft=2,Es=3,As=4,Is=5,qt=6,ks=7,Cs=n=>(t,...e)=>(t.some(s=>s===void 0)&&console.warn(`Some template strings are undefined.
This is probably caused by illegal octal escape sequences.`),e.some(s=>s==null?void 0:s._$litStatic$)&&Q("",`Static values 'literal' or 'unsafeStatic' cannot be used as values to non-static templates.
Please use the static 'html' tag function. See https://lit.dev/docs/templates/expressions/#static-expressions`),{_$litType$:n,strings:t,values:e}),P=Cs(Je),D=Symbol.for("lit-noChange"),g=Symbol.for("lit-nothing"),me=new WeakMap,O=j.createTreeWalker(j,129);let z=mt;function Ke(n,t){if(!Array.isArray(n)||!n.hasOwnProperty("raw")){let e="invalid template strings array";throw e=`
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g,`
`),new Error(e)}return de!==void 0?de.createHTML(t):t}const qe=(n,t)=>{const e=n.length-1,s=[];let i=t===Rt?"<svg>":"",o,r=Y;for(let d=0;d<e;d++){const c=n[d];let f=-1,h,l=0,u;for(;l<c.length&&(r.lastIndex=l,u=r.exec(c),u!==null);)if(l=r.lastIndex,r===Y){if(u[le]==="!--")r=he;else if(u[le]!==void 0)r=ue;else if(u[vt]!==void 0)We.test(u[vt])&&(o=new RegExp(`</${u[vt]}`,"g")),r=C;else if(u[bs]!==void 0)throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions")}else r===C?u[Ts]===">"?(r=o??Y,f=-1):u[fe]===void 0?f=-2:(f=r.lastIndex-u[xs].length,h=u[fe],r=u[pe]===void 0?C:u[pe]==='"'?St:wt):r===St||r===wt?r=C:r===he||r===ue?r=Y:(r=C,o=void 0);console.assert(f===-1||r===C||r===wt||r===St,"unexpected parse state B");const p=r===C&&n[d+1].startsWith("/>")?" ":"";i+=r===Y?c+vs:f>=0?(s.push(h),c.slice(0,f)+Wt+c.slice(f)+T+p):c+T+(f===-2?d:p)}const a=i+(n[e]||"<?>")+(t===Rt?"</svg>":"");return[Ke(n,a),s]};class nt{constructor({strings:t,["_$litType$"]:e},s){this.parts=[];let i,o=0,r=0;const a=t.length-1,d=this.parts,[c,f]=qe(t,e);if(this.el=nt.createElement(c,s),O.currentNode=this.el.content,e===Rt){const h=this.el.content.firstChild;h.replaceWith(...h.childNodes)}for(;(i=O.nextNode())!==null&&d.length<a;){if(i.nodeType===1){{const h=i.localName;if(/^(?:textarea|template)$/i.test(h)&&i.innerHTML.includes(T)){const l=`Expressions are not supported inside \`${h}\` elements. See https://lit.dev/msg/expression-in-${h} for more information.`;if(h==="template")throw new Error(l);Q("",l)}}if(i.hasAttributes())for(const h of i.getAttributeNames())if(h.endsWith(Wt)){const l=f[r++],p=i.getAttribute(h).split(T),m=/([.?@])?(.*)/.exec(l);d.push({type:Kt,index:o,name:m[2],strings:p,ctor:m[1]==="."?Fe:m[1]==="?"?Xe:m[1]==="@"?Ze:it}),i.removeAttribute(h)}else h.startsWith(T)&&(d.push({type:qt,index:o}),i.removeAttribute(h));if(We.test(i.tagName)){const h=i.textContent.split(T),l=h.length-1;if(l>0){i.textContent=ut?ut.emptyScript:"";for(let u=0;u<l;u++)i.append(h[u],tt()),O.nextNode(),d.push({type:ft,index:++o});i.append(h[l],tt())}}}else if(i.nodeType===8)if(i.data===Jt)d.push({type:ft,index:o});else{let l=-1;for(;(l=i.data.indexOf(T,l+1))!==-1;)d.push({type:ks,index:o}),l+=T.length-1}o++}if(f.length!==r)throw new Error('Detected duplicate attribute bindings. This occurs if your template has duplicate attributes on an element tag. For example "<input ?disabled=${true} ?disabled=${false}>" contains a duplicate "disabled" attribute. The error was detected in the following template: \n`'+t.join("${...}")+"`");y&&y({kind:"template prep",template:this,clonableTemplate:this.el,parts:this.parts,strings:t})}static createElement(t,e){const s=j.createElement("template");return s.innerHTML=t,s}}function H(n,t,e=n,s){var r,a;if(t===D)return t;let i=s!==void 0?(r=e.__directives)==null?void 0:r[s]:e.__directive;const o=et(t)?void 0:t._$litDirective$;return(i==null?void 0:i.constructor)!==o&&((a=i==null?void 0:i._$notifyDirectiveConnectionChanged)==null||a.call(i,!1),o===void 0?i=void 0:(i=new o(n),i._$initialize(n,e,s)),s!==void 0?(e.__directives??(e.__directives=[]))[s]=i:e.__directive=i),i!==void 0&&(t=H(n,i._$resolve(n,t.values),i,s)),t}class Ge{constructor(t,e){this._$parts=[],this._$disconnectableChildren=void 0,this._$template=t,this._$parent=e}get parentNode(){return this._$parent.parentNode}get _$isConnected(){return this._$parent._$isConnected}_clone(t){const{el:{content:e},parts:s}=this._$template,i=((t==null?void 0:t.creationScope)??j).importNode(e,!0);O.currentNode=i;let o=O.nextNode(),r=0,a=0,d=s[0];for(;d!==void 0;){if(r===d.index){let c;d.type===ft?c=new yt(o,o.nextSibling,this,t):d.type===Kt?c=new d.ctor(o,d.name,d.strings,this,t):d.type===qt&&(c=new Qe(o,this,t)),this._$parts.push(c),d=s[++a]}r!==(d==null?void 0:d.index)&&(o=O.nextNode(),r++)}return O.currentNode=j,i}_update(t){let e=0;for(const s of this._$parts)s!==void 0&&(y&&y({kind:"set part",part:s,value:t[e],valueIndex:e,values:t,templateInstance:this}),s.strings!==void 0?(s._$setValue(t,s,e),e+=s.strings.length-2):s._$setValue(t[e])),e++}}let yt=class Ye{get _$isConnected(){var t;return((t=this._$parent)==null?void 0:t._$isConnected)??this.__isConnected}constructor(t,e,s,i){this.type=ft,this._$committedValue=g,this._$disconnectableChildren=void 0,this._$startNode=t,this._$endNode=e,this._$parent=s,this.options=i,this.__isConnected=(i==null?void 0:i.isConnected)??!0,this._textSanitizer=void 0}get parentNode(){let t=b(this._$startNode).parentNode;const e=this._$parent;return e!==void 0&&(t==null?void 0:t.nodeType)===11&&(t=e.parentNode),t}get startNode(){return this._$startNode}get endNode(){return this._$endNode}_$setValue(t,e=this){var s;if(this.parentNode===null)throw new Error("This `ChildPart` has no `parentNode` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's `innerHTML` or `textContent` can do this.");if(t=H(this,t,e),et(t))t===g||t==null||t===""?(this._$committedValue!==g&&(y&&y({kind:"commit nothing to child",start:this._$startNode,end:this._$endNode,parent:this._$parent,options:this.options}),this._$clear()),this._$committedValue=g):t!==this._$committedValue&&t!==D&&this._commitText(t);else if(t._$litType$!==void 0)this._commitTemplateResult(t);else if(t.nodeType!==void 0){if(((s=this.options)==null?void 0:s.host)===t){this._commitText("[probable mistake: rendered a template's host in itself (commonly caused by writing ${this} in a template]"),console.warn("Attempted to render the template host",t,"inside itself. This is almost always a mistake, and in dev mode ","we render some warning text. In production however, we'll ","render it, which will usually result in an error, and sometimes ","in the element disappearing from the DOM.");return}this._commitNode(t)}else Ue(t)?this._commitIterable(t):this._commitText(t)}_insert(t){return b(b(this._$startNode).parentNode).insertBefore(t,this._$endNode)}_commitNode(t){var e;if(this._$committedValue!==t){if(this._$clear(),z!==mt){const s=(e=this._$startNode.parentNode)==null?void 0:e.nodeName;if(s==="STYLE"||s==="SCRIPT"){let i="Forbidden";throw s==="STYLE"?i="Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css`...` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.":i="Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.",new Error(i)}}y&&y({kind:"commit node",start:this._$startNode,parent:this._$parent,value:t,options:this.options}),this._$committedValue=this._insert(t)}}_commitText(t){if(this._$committedValue!==g&&et(this._$committedValue)){const e=b(this._$startNode).nextSibling;this._textSanitizer===void 0&&(this._textSanitizer=Mt(e,"data","property")),t=this._textSanitizer(t),y&&y({kind:"commit text",node:e,value:t,options:this.options}),e.data=t}else{const e=j.createTextNode("");this._commitNode(e),this._textSanitizer===void 0&&(this._textSanitizer=Mt(e,"data","property")),t=this._textSanitizer(t),y&&y({kind:"commit text",node:e,value:t,options:this.options}),e.data=t}this._$committedValue=t}_commitTemplateResult(t){var o;const{values:e,["_$litType$"]:s}=t,i=typeof s=="number"?this._$getTemplate(t):(s.el===void 0&&(s.el=nt.createElement(Ke(s.h,s.h[0]),this.options)),s);if(((o=this._$committedValue)==null?void 0:o._$template)===i)y&&y({kind:"template updating",template:i,instance:this._$committedValue,parts:this._$committedValue._$parts,options:this.options,values:e}),this._$committedValue._update(e);else{const r=new Ge(i,this),a=r._clone(this.options);y&&y({kind:"template instantiated",template:i,instance:r,parts:r._$parts,options:this.options,fragment:a,values:e}),r._update(e),y&&y({kind:"template instantiated and updated",template:i,instance:r,parts:r._$parts,options:this.options,fragment:a,values:e}),this._commitNode(a),this._$committedValue=r}}_$getTemplate(t){let e=me.get(t.strings);return e===void 0&&me.set(t.strings,e=new nt(t)),e}_commitIterable(t){Be(this._$committedValue)||(this._$committedValue=[],this._$clear());const e=this._$committedValue;let s=0,i;for(const o of t)s===e.length?e.push(i=new Ye(this._insert(tt()),this._insert(tt()),this,this.options)):i=e[s],i._$setValue(o),s++;s<e.length&&(this._$clear(i&&b(i._$endNode).nextSibling,s),e.length=s)}_$clear(t=b(this._$startNode).nextSibling,e){var s;for((s=this._$notifyConnectionChanged)==null||s.call(this,!1,!0,e);t&&t!==this._$endNode;){const i=b(t).nextSibling;b(t).remove(),t=i}}setConnected(t){var e;if(this._$parent===void 0)this.__isConnected=t,(e=this._$notifyConnectionChanged)==null||e.call(this,t);else throw new Error("part.setConnected() may only be called on a RootPart returned from render().")}};class it{get tagName(){return this.element.tagName}get _$isConnected(){return this._$parent._$isConnected}constructor(t,e,s,i,o){this.type=Kt,this._$committedValue=g,this._$disconnectableChildren=void 0,this.element=t,this.name=e,this._$parent=i,this.options=o,s.length>2||s[0]!==""||s[1]!==""?(this._$committedValue=new Array(s.length-1).fill(new String),this.strings=s):this._$committedValue=g,this._sanitizer=void 0}_$setValue(t,e=this,s,i){const o=this.strings;let r=!1;if(o===void 0)t=H(this,t,e,0),r=!et(t)||t!==this._$committedValue&&t!==D,r&&(this._$committedValue=t);else{const a=t;t=o[0];let d,c;for(d=0;d<o.length-1;d++)c=H(this,a[s+d],e,d),c===D&&(c=this._$committedValue[d]),r||(r=!et(c)||c!==this._$committedValue[d]),c===g?t=g:t!==g&&(t+=(c??"")+o[d+1]),this._$committedValue[d]=c}r&&!i&&this._commitValue(t)}_commitValue(t){t===g?b(this.element).removeAttribute(this.name):(this._sanitizer===void 0&&(this._sanitizer=z(this.element,this.name,"attribute")),t=this._sanitizer(t??""),y&&y({kind:"commit attribute",element:this.element,name:this.name,value:t,options:this.options}),b(this.element).setAttribute(this.name,t??""))}}class Fe extends it{constructor(){super(...arguments),this.type=Es}_commitValue(t){this._sanitizer===void 0&&(this._sanitizer=z(this.element,this.name,"property")),t=this._sanitizer(t),y&&y({kind:"commit property",element:this.element,name:this.name,value:t,options:this.options}),this.element[this.name]=t===g?void 0:t}}class Xe extends it{constructor(){super(...arguments),this.type=As}_commitValue(t){y&&y({kind:"commit boolean attribute",element:this.element,name:this.name,value:!!(t&&t!==g),options:this.options}),b(this.element).toggleAttribute(this.name,!!t&&t!==g)}}class Ze extends it{constructor(t,e,s,i,o){if(super(t,e,s,i,o),this.type=Is,this.strings!==void 0)throw new Error(`A \`<${t.localName}>\` has a \`@${e}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`)}_$setValue(t,e=this){if(t=H(this,t,e,0)??g,t===D)return;const s=this._$committedValue,i=t===g&&s!==g||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,o=t!==g&&(s===g||i);y&&y({kind:"commit event listener",element:this.element,name:this.name,value:t,options:this.options,removeListener:i,addListener:o,oldListener:s}),i&&this.element.removeEventListener(this.name,this,s),o&&this.element.addEventListener(this.name,this,t),this._$committedValue=t}handleEvent(t){var e;typeof this._$committedValue=="function"?this._$committedValue.call(((e=this.options)==null?void 0:e.host)??this.element,t):this._$committedValue.handleEvent(t)}}class Qe{constructor(t,e,s){this.element=t,this.type=qt,this._$disconnectableChildren=void 0,this._$parent=e,this.options=s}get _$isConnected(){return this._$parent._$isConnected}_$setValue(t){y&&y({kind:"commit to element binding",element:this.element,value:t,options:this.options}),H(this,t)}}const Ms={_boundAttributeSuffix:Wt,_marker:T,_markerMatch:Jt,_HTML_RESULT:Je,_getTemplateHtml:qe,_TemplateInstance:Ge,_isIterable:Ue,_resolveDirective:H,_ChildPart:yt,_AttributePart:it,_BooleanAttributePart:Xe,_EventPart:Ze,_PropertyPart:Fe,_ElementPart:Qe},bt=$.litHtmlPolyfillSupportDevMode;bt==null||bt(nt,yt);($.litHtmlVersions??($.litHtmlVersions=[])).push("3.1.3");$.litHtmlVersions.length>1&&Q("multiple-versions","Multiple versions of Lit loaded. Loading multiple versions is not recommended.");const L=(n,t,e)=>{if(t==null)throw new TypeError(`The container to render into may not be ${t}`);const s=ys++,i=(e==null?void 0:e.renderBefore)??t;let o=i._$litPart$;if(y&&y({kind:"begin render",id:s,value:n,container:t,options:e,part:o}),o===void 0){const r=(e==null?void 0:e.renderBefore)??null;i._$litPart$=o=new yt(t.insertBefore(tt(),r),r,void 0,e??{})}return o._$setValue(n),y&&y({kind:"end render",id:s,value:n,container:t,options:e,part:o}),o};L.setSanitizer=gs,L.createSanitizer=Mt,L._testOnlyClearSanitizerFactoryDoNotCallOrElse=$s;/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const tn={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},en=n=>(...t)=>({_$litDirective$:n,values:t});class nn{constructor(t){}get _$isConnected(){return this._$parent._$isConnected}_$initialize(t,e,s){this.__part=t,this._$parent=e,this.__attributeIndex=s}_$resolve(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{_ChildPart:Rs}=Ms;var ve,we;const E=(ve=window.ShadyDOM)!=null&&ve.inUse&&((we=window.ShadyDOM)==null?void 0:we.noPatch)===!0?window.ShadyDOM.wrap:n=>n,ye=()=>document.createComment(""),F=(n,t,e)=>{var o;const s=E(n._$startNode).parentNode,i=t===void 0?n._$endNode:t._$startNode;if(e===void 0){const r=E(s).insertBefore(ye(),i),a=E(s).insertBefore(ye(),i);e=new Rs(r,a,n,n.options)}else{const r=E(e._$endNode).nextSibling,a=e._$parent,d=a!==n;if(d){(o=e._$reparentDisconnectables)==null||o.call(e,n),e._$parent=n;let c;e._$notifyConnectionChanged!==void 0&&(c=n._$isConnected)!==a._$isConnected&&e._$notifyConnectionChanged(c)}if(r!==i||d){let c=e._$startNode;for(;c!==r;){const f=E(c).nextSibling;E(s).insertBefore(c,i),c=f}}}return e},M=(n,t,e=n)=>(n._$setValue(t,e),n),Ns={},Os=(n,t=Ns)=>n._$committedValue=t,Ps=n=>n._$committedValue,Tt=n=>{var s;(s=n._$notifyConnectionChanged)==null||s.call(n,!1,!0);let t=n._$startNode;const e=E(n._$endNode).nextSibling;for(;t!==e;){const i=E(t).nextSibling;E(t).remove(),t=i}};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const _e=(n,t,e)=>{const s=new Map;for(let i=t;i<=e;i++)s.set(n[i],i);return s};class Ls extends nn{constructor(t){if(super(t),t.type!==tn.CHILD)throw new Error("repeat() can only be used in text expressions")}_getValuesAndKeys(t,e,s){let i;s===void 0?s=e:e!==void 0&&(i=e);const o=[],r=[];let a=0;for(const d of t)o[a]=i?i(d,a):a,r[a]=s(d,a),a++;return{values:r,keys:o}}render(t,e,s){return this._getValuesAndKeys(t,e,s).values}update(t,[e,s,i]){const o=Ps(t),{values:r,keys:a}=this._getValuesAndKeys(e,s,i);if(!Array.isArray(o))return this._itemKeys=a,r;const d=this._itemKeys??(this._itemKeys=[]),c=[];let f,h,l=0,u=o.length-1,p=0,m=r.length-1;for(;l<=u&&p<=m;)if(o[l]===null)l++;else if(o[u]===null)u--;else if(d[l]===a[p])c[p]=M(o[l],r[p]),l++,p++;else if(d[u]===a[m])c[m]=M(o[u],r[m]),u--,m--;else if(d[l]===a[m])c[m]=M(o[l],r[m]),F(t,c[m+1],o[l]),l++,m--;else if(d[u]===a[p])c[p]=M(o[u],r[p]),F(t,o[l],o[u]),u--,p++;else if(f===void 0&&(f=_e(a,p,m),h=_e(d,l,u)),!f.has(d[l]))Tt(o[l]),l++;else if(!f.has(d[u]))Tt(o[u]),u--;else{const _=h.get(a[p]),S=_!==void 0?o[_]:null;if(S===null){const w=F(t,o[l]);M(w,r[p]),c[p]=w}else c[p]=M(S,r[p]),F(t,o[l],S),o[_]=null;p++}for(;p<=m;){const _=F(t,c[m+1]);M(_,r[p]),c[p++]=_}for(;l<=u;){const _=o[l++];_!==null&&Tt(_)}return this._itemKeys=a,Os(t,c),D}}const Vs=en(Ls);/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const js=1;class Gt extends nn{constructor(t){if(super(t),this._value=g,t.type!==tn.CHILD)throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`)}render(t){if(t===g||t==null)return this._templateResult=void 0,this._value=t;if(t===D)return t;if(typeof t!="string")throw new Error(`${this.constructor.directiveName}() called with a non-string value`);if(t===this._value)return this._templateResult;this._value=t;const e=[t];return e.raw=e,this._templateResult={_$litType$:this.constructor.resultType,strings:e,values:[]}}}Gt.directiveName="unsafeHTML";Gt.resultType=js;const Ds=en(Gt);function sn(n,t){let e=0;return P`${Vs(n,s=>(s==null?void 0:s.id)??e++,(s,i)=>t(s))}`}const rt={};async function zs({input:{name:n}}){if(rt[n])return P`${rt[n]}`;let t=`http://localhost:5173/${n}.html`;return fetch(t).then(e=>e.text()).then(e=>(rt[n]=Ds(e),P`${rt[n]}`)).catch(e=>P`An error occur during fetching template: ${e}`)}class xt{constructor(t,e,s=[],i=""){k(this,"id",0);k(this,"title","");k(this,"sub_title","");k(this,"tags",[]);k(this,"description","");k(this,"src","");this.id=t,this.title=e,this.tags=s,this.src=i}}const Hs=n=>P`
    <section class="m-5 bg-#435585 text-#F5E8C7 rounded-xl px-2 py-1" hover="cursor-pointer">
        <small hover="text-fuchsia" transition>2023-01-07</small>
        <h3 class="title" text-xl mt-1 >${n==null?void 0:n.title}</h3>
        <h5 class="sub_title" text-sm my-2>${n==null?void 0:n.sub_title}</h5>
        <span class="tag">${sn((n==null?void 0:n.tags)??[],t=>P`<i class="chip">#${t}</i>`)}</span>
    </section>
`,Bs=n=>P`
    ${sn(n,Hs)}
`,Us=Ut({types:{context:{},events:{}},actions:{loadUI:({context:n},{template:t})=>{L(t,n.ui.root)}}}).createMachine({initial:"idle",context:{ui:{root:document.getElementById("route"),items:[]},posts:[new xt(0,"Participate Advent of Code for the first time",["rust","js"],"first_attempt"),new xt(1,"Participate Advent of Code for the second time",["python"],"second_attempt"),new xt(2,"Participate Advent of Code for the third time",["c++"],"third_attempt")]},states:{idle:{on:{render:{target:"render"}}},render:{entry:({context:n,system:t})=>{L(Bs(n.posts),n.ui.root),n.ui.root.querySelectorAll("section").forEach((e,s)=>e.addEventListener("click",i=>{let o=n.posts[s].src;t.get("@post").send({type:"render",template:o})}))},always:"idle"}}}),Ws=Ut({types:{context:{},input:{},events:{}},actors:{loadTemplateAsync:os(zs)}}).createMachine({initial:"idle",context:({input:n})=>({ui:{body:document.body,route:document.getElementById("route")},template:n.template}),states:{idle:{on:{render:{target:"render"}}},render:{invoke:{src:"loadTemplateAsync",input:({event:n})=>(ms(n,"render"),{name:n.template}),onDone:{actions:({context:n,event:t})=>L(t.output,n.ui.route),target:"idle"}}}}}),Js=Ut({types:{context:{},events:{}},actions:{loadUI:({context:n},{template:t})=>{L(t,n.ui.route)}},actors:{home_page:Us,post_detail:Ws}}).createMachine({initial:"home_page",invoke:[{src:"home_page",systemId:"@home"},{src:"post_detail",systemId:"@post",input:{template:"sample_blog"}}],entry:[({self:n})=>{var t,e;(t=document.querySelector(".home"))==null||t.addEventListener("click",s=>n.send({type:"home_page"})),(e=document.querySelector(".detail"))==null||e.addEventListener("click",s=>n.send({type:"detail_page"}))}],context:({})=>({ui:{body:document.body,route:document.getElementById("route")}}),states:{idle:{on:{home_page:"home_page",detail_page:"detail_page"}},home_page:{entry:ae(({system:n})=>n.get("@home"),{type:"render"}),always:"idle"},detail_page:{entry:ae(({system:n})=>n.get("@post"),{type:"render",template:"sample_blog"}),always:"idle"}}}),Ks=X(Js);Ks.start();
