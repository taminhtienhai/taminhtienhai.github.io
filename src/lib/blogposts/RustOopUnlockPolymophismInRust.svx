---
title: 'Rust OOP: Unlock Polymorphism in Rust'
subtitle: ''
description: 'Markdown is a lightweight markup language used to format plain text. It is widely used for documentation, writing blogs, and creating formatted content easily.'
created_date: '2025-04-23'
tags:
    - 'markdown'
---

## I. Má»Ÿ Ä‘áº§u

Chao xÃ¬n, xin chÃ o, ráº¥t vui vÃ¬ báº¡n Ä‘Ã£ dÃ nh thá»i gian Ä‘á»ƒ xem nhá»¯ng chia sáº» cá»§a mÃ¬nh trong lÄ©nh vá»±c láº­p trÃ¬nh. VÃ  dÃ nh cho nhá»¯ng ai Ä‘Ã£ khá»Ÿi Ä‘áº§u con Ä‘Æ°á»ng láº­p trÃ¬nh thÃ´ng qua nhá»¯ng video Java cá»§a máº¥y anh á»Ÿ Ä‘áº¥t nÆ°á»›c cÃ³ dÃ¢n sá»‘ Ä‘á»©ng thá»© 2 tháº¿ giá»›i, ta cÃ³ thá»ƒ nÃ³i ráº±ng, OOP chÃ­nh lÃ  bÃ i há»c vá»¡ lÃ²ng mÃ  báº¥t ká»³ ai cÅ©ng ~~pháº£i~~ Ä‘Ã£ thuá»™c lÃ u lÃ u nhÆ° 5 Ä‘iá»u bÃ¡c há»“ dáº¡y. ChÃ­nh vÃ¬ lÃ½ do nÃ y, khi chuyá»ƒn sang 1 ngÃ´n ngá»¯ khÃ´ng tuÃ¢n theo cÃ¡c nguyÃªn táº¯c cá»§a Java, viá»‡c Ã¡p Ä‘áº·t mindset cÅ© vÃ  Ä‘áº·t ra nhá»¯ng so sÃ¡nh lÃ  Ä‘iá»u khÃ³ trÃ¡nh khá»i.

Trong bÃ i viáº¿t nÃ y, mÃ¬nh sáº½ thá»­ Ã¡p dá»¥ng mindset khi code Java lÃªn Rust Ä‘á»ƒ xem ráº±ng chÃºng cÃ³ nhá»¯ng Æ°u/nhÆ°á»£c Ä‘iá»ƒm gÃ¬ vÃ  táº¡i sao Rust láº¡i khÃ¡c biá»‡t so vá»›i cÃ¡c ngÃ´n ngá»¯ khÃ¡c vá» máº·t nÃ y. Äá»ƒ bÃ i viáº¿t nÃ y dá»… theo dÃµi, mÃ¬nh sáº½ táº­p trung vÃ o nguyÃªn lÃ½ ná»•i tiáº¿ng vÃ  máº¡nh máº½ nháº¥t cá»§a Java, tÃ­nh <u>Ä‘a hÃ¬nh</u> (polymorphism). CÃ¹ng nhau tÃ¬m hiá»ƒu nhÃ©, let's gooooooo. 

## II. TÃ­nh Ä‘a hÃ¬nh (Polymorphism)

NguyÃªn lÃ½ nÃ y **cho phÃ©p báº¡n táº¡o ra nhiá»u káº¿t quáº£ khÃ¡c nhau tá»« 1 nguá»“n**. Trong Java ta cÃ³ thá»ƒ Ä‘áº¡t Ä‘Æ°á»£c Ä‘iá»u nÃ y thÃ´ng qua viá»‡c override method tá»« 1 interface, class hoáº·c abstract class.

```java
interface LLM {
    void bipbop();
}
class ChatGPT implements LLM { ... } // override `bipbop`
class Gemini implements LLM { ... } // override `bipbop`
class Claude implements LLM { ... } // override `bipbop`
```

Äá»ƒ Ä‘áº¡t Ä‘Æ°á»£c tÃ­nh nÄƒng nÃ y, ngÃ´n ngá»¯ lÃ¢p trÃ¬nh sá»­ dá»¥ng cÆ¡ cháº¿ vtable, báº¡n cÃ³ thá»ƒ hiá»ƒu ráº±ng vtable Ä‘Æ°á»£c xÃ¢y dá»±ng giá»‘ng nhÆ° 1 Dictionary (danh sÃ¡ch cÃ¡c key-value) vá»›i *key* lÃ  id cá»§a class vÃ  *value* lÃ  con trá» trá» tá»›i vá»‹ trÃ­ mÃ  class Ä‘Æ°á»£c khá»Ÿi táº¡o (sau khi gá»i tá»« khÃ³a *new*).

{{Váº½ hÃ¬nh minh há»a}}

ÄÃ¢y lÃ  kiáº¿n trÃºc phá»• biáº¿n vÃ  mang láº¡i hiá»‡u quáº£ cao nÃªn Ä‘Æ°á»£c Ã¡p dá»¥ng trong má»i ngÃ´n ngá»¯ láº­p trÃ¬nh cÃ³ sá»­ dá»¥ng tÃ­nh Ä‘a hÃ¬nh (polymorphism). Tuy nhiÃªn, náº¿u quan sÃ¡t ká»¹ ta váº«n cÃ³ thá»ƒ tháº¥y ráº±ng khi sá»­ dá»¥ng vtable sáº½ tá»‘n thÃªm chi phÃ­ Ä‘á»ƒ tÃ¬m ra Ä‘Æ°á»£c con trá» tá»›i Ä‘á»‹a chá»‰ cáº§n tÃ¬m, trong 1 vÃ i tÃ¬nh huá»‘ng khi ta Ä‘Ã£ xÃ¡c Ä‘á»‹nh rÃµ class muá»‘n gá»i thÃ¬ Ä‘Ã¢y lÃ  1 sá»± dÆ° thá»«a khÃ´ng cáº§n thiáº¿t. Äá»™i ngÅ© thiáº¿t káº¿ Rust Ä‘Ã£ nhÃ¬n ra vÃ  tá»‘i Æ°u hÃ³a cho trÆ°á»ng há»£p nÃ y, mÃ¬nh sáº½ nÃ³i rÃµ hÆ¡n á»Ÿ pháº§n tiáº¿p theo.

## III. Dynamic Dispatch

HoÃ£n láº¡i 1 chÃºt sá»± pháº¥n khÃ­ch trÆ°á»›c khi chÃºng ta tÃ¬m hiá»ƒu xem Rust Ä‘Ã£ tá»‘i Æ°u hÃ³a nhÆ° tháº¿ nÃ o, hÃ£y báº¯t Ä‘áº§u tá»« váº¥n Ä‘á» trÆ°á»›c. NhÆ° Ä‘Ã£ Ä‘á» cáº­p á»Ÿ trÃªn, dynamic polymorphism xá»­ dá»¥ng cÆ¡ cháº¿ vtable Ä‘á»ƒ quáº£n lÃ½ cÃ¡c implementation vÃ  cho phÃ©p Ä‘oáº¡n code sau Ä‘Ã¢y xáº£y ra.

```java
List<LLM> llms = Arrays.asList(new ChatGPT(), new Gemini(), new Claude());

llms.forEach(llm -> llm.bipbop());
```

Tuy nhiÃªn khi mÃ¬nh cá»‘ Ã¡p dá»¥ng vÃ o trong Rust, káº¿t quáº£ lÃ 

```rust
trait LLM {
	bipbop();
}
#[derive(Default)]
struct ChatGPT;
#[derive(Default)]
struct Gemini;
#[derive(Default)]
struct Claude;

impl LLM for ChatGPT {}
impl LLM for ChatGPT {}
impl LLM for ChatGPT {}

let llms: Vec<LLM> = Vec::from([ChatGPT::default(), Gemini::default(), Claude::default()]);
```

```

```

Äá»ƒ giáº£i thÃ­ch lÃ½ do táº¡i sao Ä‘oáº¡n code trÃªn khÃ´ng hoáº¡t Ä‘á»™ng, trÆ°á»›c háº¿t hÃ£y cháº¯c ráº±ng báº¡n Ä‘Ã£ hiá»ƒu háº¿t nhá»¯ng khÃ¡i niá»‡m sau Ä‘Ã¢y
- Pointer & FatPointer
- Heap vs Stack
- Object Allocation

Minh sáº½ giáº£i thÃ­ch 1 chÃºt vá» cÃ¡ch 1 Collection nhÆ° Vec vÃ  List chá»©a dá»¯ liá»‡u, vá» báº£n cháº¥t chÃºng lÃ  nhá»¯ng FatPointer cÃ³ chá»©a 3 dá»¯ liá»‡u quan trá»ng
1. Pointer: con trá» tá»›i vÃ¹ng nhá»› cá»§a dá»¯ liá»‡u
2. Size: Ä‘á»™ lá»›n cá»§a dá»¯ liá»‡u
3. Length: sá»‘ lÆ°á»£ng pháº§n tá»­ 

CÃ³ 1 rÃ ng buá»™c cá»±c ká»³ quan trong vá» thiáº¿t káº¿ cá»§a Collection Ä‘Ã³ lÃ  cÃ¡c pháº§n tá»­ con pháº£i cÃ³ size lÃ  **ngang nhau**.  Quay láº¡i 3 object mÃ  chÃºng ta Ä‘Ã£ khá»Ÿi táº¡o khi nÃ£y, chÃºng cÃ³ Ä‘á»™ lá»›n khÃ¡c nhau, báº¡n sáº½ tháº¯c máº¯c ráº±ng

> Náº¿u tháº¿ thÃ¬ tÃ´i chá»‰ cáº§n táº¡o ra cÃ¡c object cÃ³ cÃ¡c field giá»‘ng nhau lÃ  Ä‘Æ°á»£c mÃ ?

ThÃ¬ theo lÃ½ thuyáº¿t, cÃ¡ch lÃ m cá»§a báº¡n lÃ  khÃ´ng sai nhÆ°ng compiler hiá»‡n nay khÃ´ng Ä‘á»§ thÃ´ng minh Ä‘á»ƒ biáº¿t Ä‘Æ°á»£c chuyá»‡n nÃ y, vÃ  Ä‘á»ƒ cho an toÃ n thÃ¬ cá»© má»—i khi nhÃ¬n tháº¥y 2 object cÃ³ sá»± khÃ¡c biá»‡t vá» signature, compiler máº·c Ä‘á»‹nh lÃ  cÃ³ sá»± khÃ¡c biá»‡t vá» kÃ­ch thÆ°á»›c.

> "á»¦a váº­y táº¡i sao tháº±ng Java nÃ³ láº¡i lÃ m Ä‘Æ°á»£c?"

Yeah, Ã´ng Java Ä‘Ã£ giáº¥u nháº¹m Ä‘i 1 chuyá»‡n, nÃ³ Ä‘Ã£ ngáº§m Ä‘á»‹nh lÆ°u trá»¯ cÃ¡c con trá» thay vÃ¬ giÃ¡ trá»‹ thá»±c cá»§a tá»«ng object. VÃ  nhÆ° báº¡n biáº¿t Ä‘Ã³, pointer cÃ³ size lÃ  báº±ng nhau nÃªn váº«n thá»a rÃ ng buá»™c Ä‘Ã£ Ä‘áº·t ra.

{{Váº½ hÃ¬nh minh há»a}}

### 1. Smart Pointer

MÃ¬nh cÅ©ng Ä‘Ã£ Ä‘Æ°a ra cÃ¢u giáº£i phÃ¡p Ä‘á»ƒ Ã¡p dá»¥ng tÃ­nh Ä‘a hÃ¬nh vÃ o Rust rá»“i Ä‘Ã³, náº¿u nhÆ° báº¡n Ä‘á»§ tinh Ã½. VÃ¬ Rust khÃ´ng ngáº§m Ä‘á»‹nh cast cÃ¡c object sang pointer nÃªn ta buá»™c pháº£i lÃ m Ä‘iá»u Ä‘Ã³ 1 cÃ¡ch thá»§ cÃ´ng. CÃ´ng cá»¥ mÃ  mÃ¬nh sá»­ dá»¥ng Ä‘á»ƒ lÃ m Ä‘iá»u Ä‘Ã³ lÃ  SmartPointer, nÃ³ cho phÃ©p chÃºng ta lÆ°u trá»¯ 1 object báº¥t ká»³ vÃ o bá»™ nhá»› HEAP, sau Ä‘Ã³ tráº£ vá» con trá» tá»›i Ã´ nhá»› Ä‘Ã³. Äiá»ƒm máº¡nh lÃ  chÃºng ta khÃ´ng cáº§n quan tÃ¢m vá» viá»‡c dá»n dáº¹p sau khi xá»­ dá»¥ng, vÃ¬ sao cáº§n pháº£i dá»n dáº¹p thÃ¬ báº¡n cÃ³ thá»ƒ tÃ¬m hiá»ƒu á»Ÿ Ä‘Ã¢y {{ garbade collection vs RAII }}

Wahlla chÃºng ta Ä‘Ã£ Ä‘Æ°a cÃ¡c object cá»§a Rust vá» dáº¡ng con trá» vÃ  bÃ¢y giá» chÃºng Ä‘Ã£ cÃ³ chung kÃ­ch thÆ°á»›c. No more complains from compiler.

```rust
let lllms: Vec<Box<dyn LLM>> = Vec::from([Box::new(ChatGPT::default()), ..]);
```

### 2. Raw Pointer

CÃ³ 1 cÃ¡ch "hoang dÃ£" hÆ¡n Ä‘á»ƒ lÃ m viá»‡c nÃ y Ä‘Ã³ lÃ  báº¡n cast tháº³ng object vá» dáº¡ng raw pointer, Ä‘iá»ƒm máº¡nh cá»§a cÃ¡ch lÃ m nÃ y lÃ  khÃ´ng chá»‰ dÃ i dÃ²ng mÃ  cÃ²n giÃºp báº¡n cÃ³ cÆ¡ há»™i Ä‘á»ƒ Ä‘Ã¡nh sáº­p server production nhÆ° 1 hecker ~~lá»d~~ chuyÃªn nghiá»‡p.

```rust
// WARNING
let lllms: Vec<*const dyn LLM> = Vec::from([&ChatGPT::default() as *const dyn LLM), ..]);
```

> Äá»«ng thá»­ nhÃ¡, mÃ¬nh Ä‘Ã¹a thÃ´i.

### 3. std::any::Any

1 cÃ¡ch lÃ m Ã­t phá»• biáº¿n hÆ¡n Ä‘á»ƒ Ä‘áº¡t Ä‘Æ°á»£c polymorphism trong Rust lÃ  thÃ´ng qua `std::any::Any`, náº¿u ai Ä‘Ã£ tá»«ng há»c qua Typescript thÃ¬ sáº½ tháº¥y cÃ¡i nÃ y ráº¥t quen, vÃ¢ng báº¡n khÃ´ng láº§m Ä‘Ã¢u, Ä‘Ãºng nÃ³ rá»“i Ä‘áº¥y. CÃ¡ch nÃ y sáº½ bá» qua má»i typecheck cá»§a compiler vÃ  cho phÃ©p báº¡n truyá»n vÃ o báº¥t cá»© thá»© gÃ¬ báº¡n muá»‘n, vÃ  nhÆ° uncle Ben Ä‘Ã£ nÃ³i

> Sá»©c máº¡nh to lá»›n luÃ´n Ä‘i kÃ¨m vá»›i trÃ¡ch nhiá»‡m to lá»›n

Tin mÃ¬nh Ä‘i, báº¡n khÃ´ng Ä‘á»§ sá»©c Ä‘á»ƒ gÃ¡nh vÃ¡c trÃ¡ch nhiá»‡m nÃ y Ä‘Ã¢u, Ä‘Ã³ lÃ  lÃ½ do mÃ  má»—i vÅ© trá»¥ chá»‰ cÃ³ 1 anh nhá»‡n vÃ  Ä‘Ã³ khÃ´ng pháº£i báº¡n.

```rust
let lllms: Vec<Box<dyn Any>> = Vec::from([Box::new(ChatGPT::default()), ..]);

for llm in llms {
	if let Some(gpt) = llm.downcast_ref::<ChatGPT>() {
		gpt.bipbop();
	}
	...
}
```

## IV. Static Dispatch

Phew, cuá»‘i cÃ¹ng cÅ©ng Ä‘áº¿n, á»§a mÃ  nÃ£y giá» hÃ¬nh nhÆ° cÅ©ng Ä‘Ã¢u tháº¥y cÃ³ gÃ¬ tá»‡ vá» dynamic Polymorphism Ä‘Ã¢u nhá»‰? Okay tháº¿ thÃ¬ má»i báº¡n nhÃ¬n qua vi dá»¥ nÃ y.

```java
LLM gpt = new ChatGPT();
LLM gemini = new Gemini();
LLM claude = new Claude();
```

Váº­y thÃ¬ vá»›i cÃ¡ch khá»Ÿi tao trÃªn 3 variables `gpt`, `gemini` vÃ  `claude` sáº½ tráº£ vá» con trá» tá»›i trá»±c tiáº¿p Ã´ chá»©a cá»§a chÃºng nhá»‰? Nhá»‰? Hell nah, chÃºng váº«n pháº£i Ä‘i qua vtable Ä‘á»ƒ tÃ¬m Ä‘ia chá»‰ nhÃ  cá»§a mÃ¬nh rá»“i sau Ä‘Ã³ má»›i cÃ³ thá»ƒ thá»±c thi cÃ¡c hÃ m bÃªn trong.

> "Æ  tháº¿ sao Ã´ng khÃ´ng khai bÃ¡o nhÆ° nÃ y?"

```java
ChatGPT gpt = new ChatGPT();
Gemini gemini = new Gemini();
Claude claude = new Claude();
```

Okay cÃ¡ch nÃ y thÃ¬ tá»‘i Æ°u rá»“i Ä‘Ã³, tháº¿ thÃ¬ trÆ°á»ng há»£p mÃ¬nh muá»‘n táº¡o hÃ m xá»­ lÃ½ cho cÃ¡c LLM nÃ y thÃ¬ sao?

```java
/// normal people
void sendMessgeTo(LLM llm) {}

/// who does this?
/// void sendMessgeChatGPT(ChatGPT llm) {}
/// void sendMessgeGemini(Gemini llm) {}
/// void sendMessgeClause(Clause llm) {}
```

KhÃ´ng thá»ƒ nÃ o mÃ  mÃ¬nh pháº£i Ä‘i táº¡o hÃ m cho tá»«ng kiá»ƒu dá»¯ liá»‡u Ä‘Æ°á»£c Ä‘Ãºng ko, vÃ  rá»“i chÃºng ta láº¡i cÅ©ng pháº£i gáº·p láº¡i anh vtable quen thuá»™c. Rust Ä‘Æ°a cho chÃºng ta 2 giáº£i phÃ¡p.

### 1.  Keyword `impl`

"Ä‘Ã¡ trÃ¡i banh" vÃ  "nÆ°á»›c Ä‘Ã¡", cÃ¹ng 1 tá»« "Ä‘Ã¡" nhÆ°ng tÃ¹y vÃ o vá»‹ trÃ­ chÃºng sáº½ cho ra Ã½ nghÄ©a khÃ¡c nhau. Keyword `impl` ngoÃ i viá»‡c dÃ¹ng Ä‘á»ƒ khai bÃ¡o cho struct cÃ²n dÃ¹ng Ä‘á»ƒ suy luáº­n kiá»ƒu dá»¯ liá»‡u.

Function/Method Params:
```rust
fn send_message_to(llm: impl LLM) {}

send_message_to(ChatGPT::default());
send_message_to(Gemini::default());
send_message_to(Claude::default());
```

Return Type:
```rust
fn get_chatgpt(type: u64) -> impl LLM { ChatGPT::default() }
fn get_gemini(type: u64) -> impl LLM { Gemini::default() }
fn get_claude(type: u64) -> impl LLM { Claude::default() }
```

Generic Associated Type:
```rust

```

> Sao chá»— "Return Type" Ã´ng khÃ´ng táº¡o 1 hÃ m chung rá»“i tráº£ vá» theo Ä‘iá»u kiá»‡n input mÃ  láº¡i pháº£i tÃ¡ch ra lÃ m 3 hÃ m nhÆ° vÃ¢y?

ÄÃ¢y lÃ  1 háº¡n cháº¿ lá»›n cá»§a static-dispatch, gá»‰a sá»­ mÃ¬nh lÃ m nhÆ° váº­y.

```rust
fn get_llm(type: u64) -> impl LLM { /// should type compiler infer?
	if type == 1 { ChatGPT::default() }
	if type == 2 { Gemini::default() }
	if type == 3 { Claude::default() }
	ChatGPT::default()
}
```

```
```

ÄÃ¢y lÃ  viá»‡c báº¥t kháº£ thi Ä‘á»ƒ compiler cÃ³ thá»ƒ suy luáº­n Ä‘Æ°á»£c giÃ¡ trá»‹ nÃ o Ä‘Æ°á»£c dÃ¹ng Ä‘á»ƒ tráº£ vá». Äá»ƒ giáº£i thÃ­ch thÃ¬ ta hÃ£y quay vá» vÃ­ dá»¥ "Funciton/Method Params", á»Ÿ vÃ­ dá»¥ nÃ y Rust Compiler sáº½ giáº£i quyáº¿t nhÆ° sau

```rust
fn $_1_send_message_to(llm: ChatGPT) {}
fn $_2_send_message_to(llm: Gemini) {}
fn $_3_send_message_to(llm: Claude) {}

$_1_send_message_to(ChatGPT::default());
$_2_send_message_to(Gemini::default());
$_3_send_message_to(Claude::default());
```

Báº±ng cÃ¡ch phÃ¢n tÃ­ch cÃº phÃ¡p vÃ  generate ra 3 function á»Ÿ tá»«ng nÆ¡i mÃ  báº¡n gá»i tÆ°Æ¡ng á»©ng vá»›i kiá»ƒu dá»¯ liá»‡u truyá»n vÃ o, váº«n giá»¯ nguyÃªn method body, ta Ä‘Ã£ cÃ³ thá»ƒ giáº£i quyáº¿t Ä‘Æ°á»£c bÃ i toÃ¡n polymorphism mÃ  khÃ´ng cáº§n Ä‘áº¿n vtable. Äiá»u nÃ y hoÃ n toÃ n Ä‘Æ°Æ¡c thá»±c hiá»‡n bá»Ÿi Rust trong giai Ä‘oáº¡n compiletime.

NhÆ°ng Ä‘á»‘i vá»›i vÃ­ dá»¥ vá» "Return Type", hoÃ n toÃ n khÃ´ng cÃ³ cÃ¡ch nÃ o Ä‘á»ƒ dá»± Ä‘oÃ¡n Ä‘Æ°á»£c kiá»ƒu tráº£ vá» trong giai Ä‘oáº¡n compiletime vÃ¬ nhÆ° báº¡n tháº¥y `type` lÃ  1 params Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh á»Ÿ giai Ä‘oáº¡n runtime.

```rust
fn get_llm(type: u64) -> ??? {
	/// `type` = ???
	/// compiler can't choose between one in three return's values you provided
}
```

Notes:
- `impl Trait` luÃ´n luÃ´n Ä‘Æ°á»£c compiler thay tháº¿ báº±ng Type thá»±c sau quÃ¡ trÃ¬nh compile
### 2. Enum

1 trong nhá»¯ng tÃ­nh nÄƒng ná»•i báº­t báº­c nháº¥t trong ngÃ´n ngá»¯ Rust, khÃ´ng nhÆ° nhá»¯ng ngÃ´n ngá»¯ khÃ¡c, Rust enum cá»±c ká»³ máº¡nh máº½ vÃ  linh hoáº¡t, ta cÃ³ thá»ƒ sá»­ dá»¥ng nÃ³ nhÆ° 1 bá»™ khung cho dá»¯ liá»‡u cÃ³ nhiá»u state khÃ¡c nhau, enum vá»›i cÆ¡ cháº¿ typesafe sáº½ Ä‘áº£m báº£o báº¡n khÃ´ng máº¯c pháº£i sai láº§m thÃ´ng qua typecheck á»Ÿ giai Ä‘oáº¡n compiletime.

```rust
enum LLM {
	ChatGPT,
	Gemini,
	Claude,
}

let llms: Vec<LLM> = Vec::from([LLM::ChatGPT, LLM::Gemini, LLM::Clause]);

fn send_message_to(llm: LLM) {}

send_message_to(LLM::ChatGPT);
send_message_to(LLM::Gemini);
send_message_to(LLM::Claude);
```


VÃ  náº¿u báº¡n dÃ¹ng enum nhÆ° Return Type thÃ¬ vÃ­ dá»¥ sau Ä‘Ã¢y lÃ  kháº£ thi

```rust
fn get_llm(type: u64) -> LLM {
	if type == 1 { LLM::ChatGPT }
	if type == 2 { LLM::Gemini }
	if type == 3 { LLM::Claude }
	LLM::ChatGPT
}
```

Náº¿u báº¡n nghÄ© Ä‘Ã¢y chÃ­nh lÃ  giáº£i phÃ¡p hoÃ n háº£o cho toÃ n bá»™ váº¥n Ä‘á» thÃ¬ xin chia buá»“n, cÃ³ 1 sá»‘ háº¡n cháº¿ mÃ  enum Ä‘áº·t ra.

Äáº§u tiÃªn nhá»¯ng pháº§n tá»­ con cá»§a 1 enum Ä‘Æ°á»£c gá»i lÃ  **Enum Variant**
```rust
// this all LLM's variants
LLM::ChatGPT
LLM::Gemini
LLM::Claude
```

Báº¡n khÃ´ng thá»ƒ sá»­ dá»¥ng **Enum Variant** nhÆ° 1 ReturnType, Function/Method Params hay Generic Type
```rust
fn get_llm(type: u64) -> LLM::ChatGPT {} // fail
fn send_message_to(gpt: LLM::ChatGPT) {} // fail
let llms: Vec<LLM::ChatGPT> = vec![]; // fail
```

Báº¡n khÃ´ng thá»ƒ impl Trait to 1 **Enum Variant**
```rust
impl SomeTrait for LLM::ChatGPT {} // fail
```

**Enum Variant**  dÃ¹ trong giá»‘ng 1 struct/tuple nhÆ°ng láº¡i khÃ´ng cÃ³ cÃ¡c kháº£ nÄƒng nhÆ° 1 struct/tuple, vÃ­ dá»¥ nhÆ° sá»­ dá»¥ng `#[derive]` macro

```rust
enum LLM {
	#[derive(Debug)] // fail
	ChatGPT,
	Gemini,
	Claude,
}
```

ChÃ­nh vÃ¬ váº­y mÃ  khi cÃ¢n nháº¯c giá»¯a viá»‡c sá»­ dá»¥ng `impl` vÃ  `enum` báº¡n cáº§n cháº¯c ráº±ng Ä‘Ã£ náº¯m rÃµ cÃ¡c giá»›i háº¡n cá»§a tá»«ng loáº¡i.


{{Rust stack allocation vs Java heap allocation}}

Notes:
- Viá»‡c sá»­ dá»¥ng enum sáº½ giá»›i háº¡n kháº£ nÄƒng cá»§a cÃ¡c kiá»ƒu dá»¯ liá»‡u bÃªn trong nÃ³
- KÃ­ch thÆ°á»›c cá»§a Enum Ä‘Æ°á»£c quyáº¿t Ä‘á»‹nh báº±ng vá»›i size cá»§a Variant lá»›n nháº¥t, Ä‘iá»u nÃ y dáº«n Ä‘áº¿n viá»‡c lÃ£ng phÃ­ bá»™ nhá»› hÆ¡n so vá»›i SmartPointer

## V. Káº¿t luáº­n

CÃ¹ng Ä‘iá»ƒm láº¡i nhá»¯ng cÃ¡ch mÃ  báº¡n cÃ³ thá»ƒ Ã¡p dá»¥ng tÃ­nh polymorphism vÃ o trong 1 project Rust

-  Dynamic Dispatch: Báº¡n muá»‘n má»i thá»© nhanh chÃ³ng vÃ  khÃ´ng quan trá»ng performance
	- Smart Pointer: You have a life to live âœ…
	- Raw Pointer: You don't have a life âŒ
	- Any: It's depend
-  Static Dispatch: Performance & Typesafe
	- Keyword `impl`: Everything happen at compiletime ğŸğŸğŸ
	- Enum: Slightly footprint, but still fast as f*** ğŸğŸ

## Advanced Topics

1. Fat Pointer vs Normal Pointer
2. Allocation in Rust
3. Rust Enum vs Java Enum vs Typescript Enum
4. Rust Trait vs Java Interface